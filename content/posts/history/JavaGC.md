---
title: "Java Gc"
date: 2020-07-27 17:04:15.369000
draft: false
bookComments: true
tags: ["2023-05-07从halo博客迁移"]
# bookSearchExclude: false
---

**堆的回收区域**

![GC](/images/image-e3306adf515a4f35bcb374771abd444d.png)


- 新生代（Young Generation）NewSize和MaxNewSize分别可以控制年轻代的初始大小和最大的大小。
- 老年代（Old Generation）。
- 永久代（Permanent Generation）【1.8以后采用元空间，不在虚拟机里，而是使用本地内存】。


**三大垃圾收集算法**
- 标记/清除算法
- 复制算法
- 标记/整理算法

**JVM GC算法**
- JVM采用“分代收集算法”对不同区域采用不同的回收算法。
- 新生代采用复制算法。
- 老年代采用标记/清除算法或标记/整理算法。

**GC过程**

![image.png](/images/image-13ac21ec2d554676a0502c67b0995704.png)

1-2、当new新对象时，Eden空间满了，使用复制算法把存活的对象复制到空的S0(S1)上。
3-4、判断S1中存活对象的年龄值，当年龄值+1达到15时（默认15，可修改），对象将进入老年代，当没有满足时，就复制进去S0中。
- 大对象直接进入老年代。
- 当对象总数大于Survivor（S0/S1）的一半时，也会直接进入老年代。

**判断对象是否存活算法**
1.引用计数算法
早期判断对象是否存活大多都是以这种算法，这种算法判断很简单，简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。

2.可达性分析算法
它的基本思路是通过一个称为“GC Roots”的对象（局部变量）为起始点，搜索所经过的路径称为引用链，当一个对象到GC Roots没有任何引用跟它连接则证明对象是不可用的。(解决了循环利用)

**Minor GC、Major GC、Full GC**
- 在年轻代Young space(包括Eden区和Survivor区)中的垃圾回收称之为 Minor GC,Minor GC只会清理年轻代.
- Major GC清理老年代，但是通常也可以指和Full GC是等价，因为收集老年代的时候往往也会伴随着升级年轻代，收集整个Java堆。
- Full GC是对新生代、老年代、永久代统一的回收。